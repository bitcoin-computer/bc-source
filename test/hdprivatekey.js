import _ from 'lodash'
import assert from 'assert'
import chai from 'chai'
import { Bitcoin } from './bitcoin'

const should = chai.should()
const { expect } = chai
const { errors } = Bitcoin
const hdErrors = errors.HDPrivateKey
const { Networks } = Bitcoin
const BufferUtil = Bitcoin.util.buffer
const { HDPrivateKey } = Bitcoin
const { Base58Check } = Bitcoin.encoding

const xprivkey =
  'xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi'
const json =
  '{"network":"livenet","depth":0,"fingerPrint":876747070,"parentFingerPrint":0,"childIndex":0,"chainCode":"873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508","privateKey":"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35","checksum":-411132559,"xprivkey":"xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi"}'

describe('HDPrivate key interface', () => {
  const expectFail = function (func, error) {
    let got = null
    try {
      func()
    } catch (e) {
      got = e instanceof error
    }
    expect(got).to.equal(true)
  }

  const expectDerivationFail = function (argument, error) {
    return expectFail(() => {
      const privateKey = new HDPrivateKey(xprivkey)
      privateKey.derive(argument)
    }, error)
  }

  const expectFailBuilding = function (argument, error) {
    return expectFail(() => new HDPrivateKey(argument), error)
  }

  const expectSeedFail = function (argument, error) {
    return expectFail(() => HDPrivateKey.fromSeed(argument), error)
  }

  it('should make a new private key from random', () => {
    should.exist(new HDPrivateKey().xprivkey)
  })

  it('should make a new private key from random for testnet', () => {
    const key = new HDPrivateKey('testnet')
    should.exist(key.xprivkey)
    key.network.name.should.equal('testnet')
  })

  it('should not be able to change read-only properties', () => {
    const hdkey = new HDPrivateKey()
    expect(() => {
      hdkey.fingerPrint = 'notafingerprint'
    }).to.throw(TypeError)
  })

  it('should error with an invalid checksum', () => {
    expectFailBuilding(`${xprivkey}1`, errors.InvalidB58Checksum)
  })

  it('can be rebuilt from a json generated by itself', () => {
    const regenerate = new HDPrivateKey(json)
    regenerate.xprivkey.should.equal(xprivkey)
  })

  it('builds a json keeping the structure and same members', () => {
    assert(_.isEqual(new HDPrivateKey(json).toJSON(), new HDPrivateKey(xprivkey).toJSON()))
  })

  describe('instantiation', () => {
    it('invalid argument: can not instantiate from a number', () => {
      expectFailBuilding(1, hdErrors.UnrecognizedArgument)
    })
    it('allows no-new calling', () => {
      HDPrivateKey(xprivkey).toString().should.equal(xprivkey)
    })
    it('allows the use of a copy constructor', () => {
      HDPrivateKey(HDPrivateKey(xprivkey)).xprivkey.should.equal(xprivkey)
    })
  })

  describe('public key', () => {
    const testnetKey = new HDPrivateKey(
      'tprv8ZgxMBicQKsPdEeU2KiGFnUgRGriMnQxrwrg6FWCBg4jeiidHRyCCdA357kfkZiGaXEapWZsGDKikeeEbvgXo3UmEdbEKNdQH9VXESmGuUK'
    )
    const livenetKey = new HDPrivateKey(
      'xprv9s21ZrQH143K3e39bnn1vyS7YFa1EAJAFGDoeHaSBsgBxgAkTEXeSx7xLvhNQNJxJwhzziWcK3znUFKRPRwWBPkKZ8ijUBa5YYpYPQmeBDX'
    )

    it('matches the network', () => {
      testnetKey.publicKey.network.should.equal(Networks.testnet)
      livenetKey.publicKey.network.should.equal(Networks.livenet)
    })

    it('cache for xpubkey works', () => {
      const privateKey = new HDPrivateKey(xprivkey)
      should.not.exist(privateKey._hdPublicKey)
      privateKey.xpubkey.should.equal(privateKey.xpubkey)
      should.exist(privateKey._hdPublicKey)
    })
  })

  it('fails when trying to derive with an invalid argument', () => {
    expectDerivationFail([], hdErrors.InvalidDerivationArgument)
  })

  it('catches early invalid paths', () => {
    expectDerivationFail('s', hdErrors.InvalidPath)
  })

  it('allows derivation of hardened keys by passing a very big number', () => {
    const privateKey = new HDPrivateKey(xprivkey)
    const derivedByNumber = privateKey.derive(0x80000000)
    const derivedByArgument = privateKey.derive(0, true)
    derivedByNumber.xprivkey.should.equal(derivedByArgument.xprivkey)
  })

  it("returns itself with 'm' parameter", () => {
    const privateKey = new HDPrivateKey(xprivkey)
    privateKey.should.equal(privateKey.derive('m'))
  })

  it('returns InvalidArgument if invalid data is given to getSerializedError', () => {
    expect(HDPrivateKey.getSerializedError(1) instanceof hdErrors.UnrecognizedArgument).to.equal(
      true
    )
  })

  it('returns InvalidLength if data of invalid length is given to getSerializedError', () => {
    const b58s = Base58Check.encode(Buffer.from('onestring'))
    expect(HDPrivateKey.getSerializedError(b58s) instanceof hdErrors.InvalidLength).to.equal(true)
  })

  it('returns InvalidNetworkArgument if an invalid network is provided', () => {
    expect(
      HDPrivateKey.getSerializedError(xprivkey, 'invalidNetwork') instanceof
        errors.InvalidNetworkArgument
    ).to.equal(true)
  })

  it('recognizes that the wrong network was asked for', () => {
    expect(
      HDPrivateKey.getSerializedError(xprivkey, 'testnet') instanceof errors.InvalidNetwork
    ).to.equal(true)
  })

  it('recognizes the correct network', () => {
    expect(HDPrivateKey.getSerializedError(xprivkey, 'livenet')).to.equal(null)
  })

  describe('on creation from seed', () => {
    it('converts correctly from an hexa string', () => {
      should.exist(HDPrivateKey.fromSeed('01234567890abcdef01234567890abcdef').xprivkey)
    })
    it('fails when argument is not a buffer or string', () => {
      expectSeedFail(1, hdErrors.InvalidEntropyArgument)
    })
    it("fails when argument doesn't provide enough entropy", () => {
      expectSeedFail('01', hdErrors.InvalidEntropyArgument.NotEnoughEntropy)
    })
    it('fails when argument provides too much entropy', () => {
      let entropy = '0'
      for (let i = 0; i < 129; i++) {
        entropy += '1'
      }
      expectSeedFail(entropy, hdErrors.InvalidEntropyArgument.TooMuchEntropy)
    })
  })

  it('correctly errors if an invalid checksum is provided', () => {
    const privKey = new HDPrivateKey(xprivkey)
    let error = null
    try {
      const buffers = privKey._buffers
      buffers.checksum = BufferUtil.integerAsBuffer(0)
      // eslint-disable-next-line no-new
      new HDPrivateKey(buffers)
    } catch (e) {
      error = e
    }
    expect(error instanceof errors.InvalidB58Checksum).to.equal(true)
  })
  it('correctly validates the checksum', () => {
    const privKey = new HDPrivateKey(xprivkey)
    expect(() => {
      const buffers = privKey._buffers
      return new HDPrivateKey(buffers)
    }).to.not.throw()
  })

  it("shouldn't matter if derivations are made with strings or numbers", () => {
    const privateKey = new HDPrivateKey(xprivkey)
    const derivedByString = privateKey.derive("m/0'/1/2'")
    const derivedByNumber = privateKey.derive(0, true).derive(1).derive(2, true)
    derivedByNumber.xprivkey.should.equal(derivedByString.xprivkey)
  })

  describe('validates paths', () => {
    it('validates correct paths', () => {
      let valid

      valid = HDPrivateKey.isValidPath("m/0'/1/2'")
      valid.should.equal(true)

      valid = HDPrivateKey.isValidPath('m')
      valid.should.equal(true)

      valid = HDPrivateKey.isValidPath(123, true)
      valid.should.equal(true)

      valid = HDPrivateKey.isValidPath(123)
      valid.should.equal(true)

      valid = HDPrivateKey.isValidPath(HDPrivateKey.Hardened + 123)
      valid.should.equal(true)

      valid = HDPrivateKey.isValidPath(HDPrivateKey.Hardened + 123, true)
      valid.should.equal(true)
    })

    const invalid = ['m/-1/12', 'bad path', 'K', 'm/', 'm/12asd', 'm/1/2//3']

    invalid.forEach((datum) => {
      it(`rejects illegal path ${datum}`, () => {
        HDPrivateKey.isValidPath(datum).should.equal(false)
        expect(HDPrivateKey._getDerivationIndexes(datum)).to.equal(null)
      })
    })

    it('generates deriving indexes correctly', () => {
      let indexes

      indexes = HDPrivateKey._getDerivationIndexes('m/-1/12')
      expect(indexes).to.equal(null)

      indexes = HDPrivateKey._getDerivationIndexes("m/0/12/12'")
      indexes.should.eql([0, 12, HDPrivateKey.Hardened + 12])

      indexes = HDPrivateKey._getDerivationIndexes("m/0/12/12'")
      indexes.should.eql([0, 12, HDPrivateKey.Hardened + 12])
    })
  })

  describe('conversion to/from buffer', () => {
    const str =
      'xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi'
    it('should roundtrip to/from a buffer', () => {
      const priv = new HDPrivateKey(str)
      const toBuffer = priv.toBuffer()
      const fromBuffer = HDPrivateKey.fromBuffer(toBuffer)
      const roundTrip = new HDPrivateKey(fromBuffer.toBuffer())
      roundTrip.xprivkey.should.equal(str)
    })
  })

  describe('conversion to plain object/json', () => {
    const plainObject = {
      network: 'livenet',
      depth: 0,
      fingerPrint: 876747070,
      parentFingerPrint: 0,
      childIndex: 0,
      chainCode: '873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508',
      privateKey: 'e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35',
      checksum: -411132559,
      xprivkey:
        'xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvN' +
        'KmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi',
    }
    it('toObject leaves no Buffer instances', () => {
      const privKey = new HDPrivateKey(xprivkey)
      const object = privKey.toObject()
      _.each(_.values(object), (value) => {
        expect(BufferUtil.isBuffer(value)).to.equal(false)
      })
    })
    it('roundtrips toObject', () => {
      expect(HDPrivateKey.fromObject(new HDPrivateKey(xprivkey).toObject()).xprivkey).to.equal(
        xprivkey
      )
    })
    it('roundtrips to JSON and to Object', () => {
      const privkey = new HDPrivateKey(xprivkey)
      expect(HDPrivateKey.fromObject(privkey.toJSON()).xprivkey).to.equal(xprivkey)
    })
    it('recovers state from JSON', () => {
      new HDPrivateKey(JSON.stringify(plainObject)).xprivkey.should.equal(xprivkey)
    })
    it('recovers state from Object', () => {
      new HDPrivateKey(plainObject).xprivkey.should.equal(xprivkey)
    })
  })
})
